<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automata Zoo</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #817a7a;
            font-family: 'Arial', sans-serif;
            color: white;
        }
        canvas {
            display: block;
            image-rendering: crisp-edges;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
        select {
            background: #1a1818;
            color: white;
            border: 2px solid #533d61;
            padding: 10px 15px;
            font-size: 16px;
            font-family: 'Arial', sans-serif;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
        }
        select:hover {
            border-color: #008080;
        }
        select option {
            background: #1a1818;
            color: white;
        }
    </style>
</head>
<body>
    <div class="controls">
        <select id="automatonSelect">
            <option value="briansBrain">Brian's Brain</option>
            <option value="rule90">Rule 90</option>
            <option value="langtonsAnt">Langton's Ant</option>
        </select>
    </div>
    <canvas id="automaton"></canvas>

    <script>
        let canvas, ctx;
        let grid, nextGrid;
        let cellSize = 3;
        let rows, cols;
        let animationSpeed = 50;
        let currentAutomaton = 'briansBrain';
        let animationId;
        let rule90Row = 0; // Track current row for Rule 90
        let ant = { x: 0, y: 0, dir: 0 }; // Langton's Ant: position and direction (0=N, 1=E, 2=S, 3=W)

        function setupCanvas() {
            canvas = document.getElementById("automaton");
            ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            cols = Math.floor(canvas.width / cellSize);
            rows = Math.floor(canvas.height / cellSize);
            grid = createInitialGrid();
            nextGrid = createGrid();
            rule90Row = 0;
            ant = { x: Math.floor(cols / 2), y: Math.floor(rows / 2), dir: 0 };
        }

        function createGrid() {
            return Array.from({ length: rows }, () => Array.from({ length: cols }, () => 0));
        }

        function createInitialGrid() {
            let newGrid = createGrid();

            switch(currentAutomaton) {
                case 'briansBrain':
                    // Sparse random initialization
                    for (let y = 0; y < rows; y++) {
                        for (let x = 0; x < cols; x++) {
                            newGrid[y][x] = Math.random() < 0.2 ? 1 : 0;
                        }
                    }
                    break;

                case 'rule90':
                    // Rule 90: Start with a single cell in the middle of the first row
                    const middleX = Math.floor(cols / 2);
                    newGrid[0][middleX] = 1;
                    break;

                case 'langtonsAnt':
                    // Langton's Ant: Start with empty grid, ant will create pattern
                    // Grid is already initialized to all 0s
                    break;
            }
            return newGrid;
        }

        function drawGrid() {
            ctx.fillStyle = "#1a1818";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    let state = grid[y][x];
                    if (state === 0) continue;

                    // Color schemes for different automata
                    switch(currentAutomaton) {
                        case 'briansBrain':
                            ctx.fillStyle = state === 1 ? "#533d61" : "#008080";
                            break;
                        case 'rule90':
                            ctx.fillStyle = "#ffffff";
                            break;
                        case 'langtonsAnt':
                            ctx.fillStyle = "#ffffff";
                            break;
                    }
                    ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }

            // Draw the ant itself
            if (currentAutomaton === 'langtonsAnt') {
                ctx.fillStyle = "#ff0000";
                ctx.fillRect(ant.x * cellSize, ant.y * cellSize, cellSize, cellSize);
            }
        }

        function countNeighbors(y, x, state = 1) {
            let sum = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    let ny = y + dy;
                    let nx = x + dx;
                    if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                        sum += grid[ny][nx] === state ? 1 : 0;
                    }
                }
            }
            return sum;
        }

        function updateBriansBrain(y, x) {
            let neighbors = countNeighbors(y, x, 1);
            if (grid[y][x] === 0 && neighbors === 2) {
                return 1; // Becomes alive
            } else if (grid[y][x] === 1) {
                return 2; // Becomes dying
            } else {
                return 0; // Dead
            }
        }

        function updateRule90() {
            // Rule 90: new cell state = XOR of left and right neighbors
            // For 1D cellular automaton displayed row by row
            if (rule90Row >= rows - 1) {
                // Scroll: shift all rows up by one
                for (let y = 0; y < rows - 1; y++) {
                    for (let x = 0; x < cols; x++) {
                        grid[y][x] = grid[y + 1][x];
                    }
                }
                // Clear the bottom row (it will be filled with the new generation)
                for (let x = 0; x < cols; x++) {
                    grid[rows - 1][x] = 0;
                }
                // Continue generating at the bottom row
                rule90Row = rows - 2;
            }

            const currentRow = rule90Row;
            const nextRow = rule90Row + 1;

            for (let x = 0; x < cols; x++) {
                const left = x > 0 ? grid[currentRow][x - 1] : 0;
                const right = x < cols - 1 ? grid[currentRow][x + 1] : 0;
                // Rule 90: XOR of left and right neighbors
                grid[nextRow][x] = (left ^ right);
            }

            rule90Row++;
        }

        function updateLangtonsAnt() {
            // Langton's Ant rules:
            // - At a white square, turn 90° right, flip the color, move forward
            // - At a black square, turn 90° left, flip the color, move forward

            const currentCell = grid[ant.y][ant.x];

            if (currentCell === 0) {
                // White square: turn right
                ant.dir = (ant.dir + 1) % 4;
                grid[ant.y][ant.x] = 1; // Flip to black
            } else {
                // Black square: turn left
                ant.dir = (ant.dir + 3) % 4; // +3 mod 4 is same as -1 mod 4
                grid[ant.y][ant.x] = 0; // Flip to white
            }

            // Move forward based on direction: 0=N, 1=E, 2=S, 3=W
            switch(ant.dir) {
                case 0: ant.y = (ant.y - 1 + rows) % rows; break; // North
                case 1: ant.x = (ant.x + 1) % cols; break;         // East
                case 2: ant.y = (ant.y + 1) % rows; break;         // South
                case 3: ant.x = (ant.x - 1 + cols) % cols; break;  // West
            }
        }

        function updateGrid() {
            if (currentAutomaton === 'rule90') {
                updateRule90();
            } else if (currentAutomaton === 'langtonsAnt') {
                updateLangtonsAnt();
            } else {
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        switch(currentAutomaton) {
                            case 'briansBrain':
                                nextGrid[y][x] = updateBriansBrain(y, x);
                                break;
                        }
                    }
                }
                [grid, nextGrid] = [nextGrid, grid];
            }
        }

        function animate() {
            drawGrid();
            updateGrid();
            animationId = setTimeout(() => requestAnimationFrame(animate), animationSpeed);
        }

        function startAutomaton() {
            setupCanvas();
            animate();
        }

        function changeAutomaton(newType) {
            currentAutomaton = newType;
            if (animationId) {
                clearTimeout(animationId);
            }
            setupCanvas();
            animate();
        }

        document.getElementById('automatonSelect').addEventListener('change', function(e) {
            changeAutomaton(e.target.value);
        });

        window.onload = startAutomaton;
        window.onresize = () => {
            if (animationId) {
                clearTimeout(animationId);
            }
            setupCanvas();
            animate();
        };
    </script>
</body>
</html>


